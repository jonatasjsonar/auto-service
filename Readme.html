<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JSonar Library to Service</title>

  <style>
    @media print {
      pre {
        page-break-inside: avoid;
      }

      p {
        text-indent: 2em;
        line-height: 1.3em;
      }

      @page {
        size: A4;
      }

      @page:right{
        @bottom-left {
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #666;
          content: "Our Cats";
          font-size: 9pt;
          color: #333;
        }

        @bottom-right {
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #666;
          content: counter(page);
          font-size: 9pt;
        }

        @top-right {
          content:  string(doctitle);
          margin: 30pt 0 10pt 0;
          font-size: 9pt;
          color: #333;
        }
      }
    }

    body {
      width: 22cm;
      height: 29.7cm;
      text-align: justify;
      margin: auto;
    }

    h2 {
      margin-top: 1cm;
      border-bottom: 1px darkblue solid;
    }

    h3 {
      border-left: 3px solid darkblue;
      padding-left: 5px;
    }

    h4 {
      padding-left: 8px;
    }
  </style>
</head>
<body>
<h2>Problem</h2>
<p>jSonar Finder has lots of dependencies that are not direct related to it.
  Most of these dependencies could be deployed as service resulting in a simpler build cycle and a easier maintenance for both Finder and its dependencies.</p>

<h3>Proposed Solution</h3>
<p>The proposed solution for this problem is to implement a functionality that would automatically scan for dependencies that
  could be deployed as service and, according to a parameter, build it as a library (jar) or as a service (war).
  This implementation should not change the dependency's code nor the GUI's code.</p>

<h4>Requirements</h4>
<ul>
  <li>The dependency's code and GUI's code should not be changed. Annotations are fine.</li>
  <li>Implementation of a parameter to control how the dependency will be deployed.</li>
  <li>The code to consume the services should be automatically generated in compile time.</li>
  <li>For this first approach, all services should be deployed in the same tomcat instance.</li>
</ul>

<h2>Solution</h2>
<p>To achieve this solution we are going to make use of Maven and Maven profiles,
  custom annotations and annotation processing, JavaPoet for code generation,
  and RestEasy.</p>

<h3>Source Code Generation</h3>
<p>JavaPoet is an API for generating Java source files. It will be used to generate the client code to access the dependencies
  that are going to be deployed as service. JavaPoet provides builders to make the process of generating new source files easier.</p>
<p>To generate classes and interfaces, JavaPoet provides a TypeSpec builder. In this builder you are going to find methods like
  addModifiers, addAnnotation, addMethod, and others. JavaPoet also provides builders for annotations (AnnotationSpec.Builder),
  methods (MethodSpec.Builder) fields (FieldSpec.Builder) and all other kinds of elements a class might have.</p>
<p>Following is an example of a class that has a main method that prints a message:</p>
<pre class="prettyprint">
  <code class="language-java">
  TypeSpec.Builder classBuilder = TypeSpec.classBuilder("HelloWorld")
          .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

  MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("main")
          .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
          .returns(void.class)
          .addParameter(String[].class, "args")
          .addStatement("$T.out.println($S)", System.class, "Hello World!");

  classBuilder.addMethod(methodBuilder.build());

  try {
      JavaFile javaFile = JavaFile.builder("com.jsonar.example", classBuilder.build()).build();
      javaFile.writeTo(System.out);

  } catch (IOException e) {
      e.printStackTrace();
  }
  </code>
</pre>
<p>The code above will generate the following output:</p>
<pre class="prettyprint">
  <code class="language-java">
  package com.jsonar.example;

  import java.lang.String;
  import java.lang.System;

  public final class HelloWorld {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
  </code>
</pre>
<p>All imports were handled automatically by JavaPoet. The addStatement method in MethodSpec.Builder accepts a syntax similar to String.format().
  It is possible to use Specifiers to make the code more readable. The following specifiers are supported:</p>
<ul>
  <li>
    <b>$L for Literals:</b>
    Emit a literal value in the output. Similar to %s in the String Formatter.
  </li>
  <li>
    <b>$S for Strings</b>
    Emit a string in the output that includes quotation marks and escaping.
  </li>
  <li>
    <b>$T for Types</b>
    Used to reference types. It will automatically generate the imports.
  </li>
  <li>
    <b>$N for Names</b>
    Used to refer another element that was generated by JavaPoet.
  </li>
</ul>

<h3>RestEasy Proxy Framework</h3>
<p>RestEasy provides an easy way to consume services through interfaces (Proxy Interfaces) annotated with JAX-RS annotations.
  Instead of using the annotations to map the request to a service, the framework uses it to get the necessary information
  to invoke a remote service.</p>
<p>The first step to make use of RestEasy proxy framework is writing the service interface and annotate it with JAX-RS annotations:</p>
<pre class="prettyprint">
  <code class="language-java">
  @Path("/random")
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public interface RandomServiceInterface {
    @GET
    @Path("/int")
    int randomInt();
  }
  </code>
</pre>
<p>And finally create the client and the request using our annotated interface:</p>
<pre class="prettyprint">
  <code class="language-java">
  ResteasyClient client = (ResteasyClient) ClientBuilder.newBuilder()
          .register(ResteasyJackson2Provider.class).build();
  ResteasyWebTarget target = client.target(UriBuilder.fromPath("http://localhost:8080/service"));
  RandomServiceInterface proxy = target.proxy(RandomServiceInterface.class);
  int randomInt = proxy.randomInt();
  </code>
</pre>
<p>This code will generate a GET request to "http://localhost:8080/service/random/int" that will return a int as response.
  The ResteasyJackson2Provider is used to parse the request and response to/from JSON.</p>

<h3>Annotation Processing</h3>
<p>Annotation Processing is a tool available in javac for processing annotations in compile time.
  It is available since Java 6 and allows the developer to perform tasks like source code validation and source code generation.
  Project Lombok, Google AutoValue and Google AutoService are examples of frameworks making use of Annotation Processing.</p>
<p>Annotation Processing works in rounds and an annotation processor is required to make use of it.
  In the first round, the compiler scans the source code looking for supported annotations and invokes the registered processors to process it.
  When the round is finished, the compiler runs the cycle again for the source code that was generated in the first round.
  The cycle goes on until there is no more source code to be processed.</p>
<p>A custom annotation is necessary to determine which classes are going to become services.
  The annotation processor will have access to all classes annotated with our custom annotation and will generate the code
  for invoking the services. This generated code will be compiled as a Finder dependency and it will have the same class name
  and methods signature as the dependency's class used to generate it.</p>

<h4>Custom Annotation</h4>
<p>As mentioned in the last section, a custom annotation will be necessary to mark all classes that are going to become service.
  Following is the code used to create a new annotation <i>@JSonarService</i>:</p>
<pre class="prettyprint" about="Teste">
  <code class="language-java">
  @Retention(RetentionPolicy.SOURCE)
  @Target(ElementType.TYPE)
  public @interface JSonarService {}
  </code>
</pre>
<ul>
  <li>
    <b>Retention: </b>
    Indicates how long this annotation will be retained.
    RetentionPolicy.SOURCE indicates that this annotation should be discarded in compile time.
  </li>
  <li>
    <b>Target: </b>
    Indicates what kind of element to which this annotation is applicable.
    ElementType.TYPE indicates that this annotation should be used in classes.
  </li>
</ul>

<h4>AbstractProcessor</h4>
<p>All annotation processors must be a subclass of javax.annotation.processing.AbstractProcessor.
  This class provides a few methods for configuration and the process method itself.</p>
<pre class="prettyprint">
  <code class="language-java">
  public class MyProcessor extends AbstractProcessor {
    @Override
    public synchronized void init(ProcessingEnvironment env){ }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) { }

    @Override
    public Set&lt;String&gt; getSupportedAnnotationTypes() { }

    @Override
    public SourceVersion getSupportedSourceVersion() { }
  }
  </code>
</pre>
<ul>
  <li>
    <b>init(ProcessingEnvironment env):</b>
    Method for required initialization. The ProcessingEnvironment class has a few helpers to handle messages,
    file generation, and some utils to process elements and types.
  </li>
  <li>
    <b>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env):</b>
    The main method of a processor. This is where the code for processing annotations must be implemented.
  </li>
  <li>
    <b>getSupportedAnnotationTypes():</b>
    Method to inform the compiler which annotations are supported by this processor. It can be replace by <i>@SupportedAnnotationTypes</i>.
  </li>
  <li>
    <b>getSupportedSourceVersion():</b>
    Method to inform the compiler which Java version is supported by this processor. It can be replace by <i>@SupportedSourceVersion</i>.
  </li>
</ul>
<p>In our processor we don't need the init method because we are going to access the ProcessingEnvironment directly from the super class.
  The process method we are going to generate the classes for consuming the services.
  The methods getSupportedAnnotationType and getSupportedSourceVersion are going to be replaced for its respective annotations.</p>
<pre class="prettyprint">
  <code class="language-java">
  @SupportedAnnotationTypes({"com.jsonar.annotation.JSonarService"})
  @SupportedSourceVersion(SourceVersion.RELEASE_8)
  @SupportedOptions({"generatedSourcesDirectory", "servicePath", "serviceAddress"})
  public class JSonarServiceProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {}
  }
  </code>
</pre>
<ul>
  <li>
    <b>@SupportedAnnotationTypes: </b>
    Indicates which annotations are going to be processed by this processor.
  </li>
  <li>
    <b>@SupportedSourceVersion: </b>
    Indicates which java version this processor supports. In this case, we are using Java 8.
  </li>
  <li>
    <b>@SupportedOptions: </b>
    Indicates all compiler options this processor accepts. Use -Akey or -Akey=value in compileArgs option.
    <ul>
      <li>generatedSourcesDirectory: Inform the path where the new code will be generated.</li>
      <li>servicePath: The service path (usually the build final name).</li>
      <li>serviceAddress: The address where service will be available. For this first approach, it will be http://localhost[:port]/</li>
    </ul>
  </li>
</ul>

<h4>Warning and Error messages</h4>
<p>The ProcessingEnvironment class provides a helper to print messages during compile time.
  At the end of a processor execution, if there's any error message, the build will fail. 
  The configuration <i>showWarnings</i> must be enable to show warning messages in maven building cycle.</p>
<pre class="prettyprint">
  <code class="language-java">
  // Prints a error message. This message will be printed in Maven's build failure message.
  this.processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);

  // Prints a warning message. The showWarnings configuration must be enable to show the message.
  this.processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, msg, element);
  </code>
</pre>

<h4>Process Method</h4>
<p>The process method is where all processing and generation of new source code is done.
  Here we will check all elements annotated with our custom annotation, validate it and generate the proxy classes to access the services.</p>
  <p>The following code returns all elements that are annotated with our custom annotation, validate if the element is a class
  and print an error for all elements that are not classes.</p>
<pre class="prettyprint">
  <code class="language-java">
  private List&lt;Element&gt; getElementsToProcess(RoundEnvironment roundEnv, TypeElement annotation) {
      Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);

      Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedClasses = annotatedElements.stream().collect(
              Collectors.partitioningBy(element -> ElementKind.CLASS == element.getKind())
      );

      List&lt;Element&gt; toProcess = annotatedClasses.get(true);
      List&lt;Element&gt; wrongUseAnnotation = annotatedClasses.get(false);

      wrongUseAnnotation.forEach(
          element -> error("@" + annotation.getSimpleName().toString() + " must be applied to classes", element)
      );
      return toProcess;
  }
  </code>
</pre>
<p>The <i>roundEnv.getElementsAnnotatedWith(annotation)</i> returns all elements in that round that are annotated with that annotation.
  This is necessary because a processor can process more than one annotation.</p>
<p>For each element that we are going to process, we need to cast it to TypeElement and, using the design pattern Visitor,
  access its information returning a JavaPoet TypeSpec.Builder.
  For this step, we are going to need a subclass of SimpleElementVisitor8 provided by Java.
  The SimpleElementVisitor8 expect 2 types to be set:</p>
<pre class="prettyprint">
  <code class="language-java">
  public class SimpleElementVisitor8&lt;R,P&gt; extends SimpleElementVisitor7&lt;R,P&gt;
  </code>
</pre>
<ul>
  <li>
    <b>R: </b>
    Returning type of our Visitor's methods. In our case we want to return a TypeSpec.Builder object from JavaPoet API.
  </li>
  <li>
    <b>P: </b>
    Type of the additional parameter to our Visitor's methods.
    In our case we are going to pass a ProcessingEnvironment to be able to print messages and to use its helpers.
  </li>
</ul>
<pre class="prettyprint">
  <code class="language-java">
  public class ClassVisitor extends SimpleElementVisitor8&lt;TypeSpec.Builder, ProcessingEnvironment&gt;
  </code>
</pre>
<h4>Proxy Interface Code Generation</h4>
<p>As mentioned before, the RestEasy Proxy Framework needs a interface that will describe our service.
  This interface should be annotated with JAX-RS annotations and must have information like path, http method and the kind of data our service produces and consumes.</p>
<p>The following code is the implementation of a Visitor that will create a builder for each of the elements that we are going to process:</p>
<pre class="prettyprint">
  <code class="language-java">
  public class ProxyInterfaceVisitor extends SimpleElementVisitor8&lt;TypeSpec.Builder, ProcessingEnvironment&gt; {
      @Override
      public TypeSpec.Builder visitType(TypeElement e, ProcessingEnvironment processingEnvironment) {
          TypeSpec.Builder newInterface = TypeSpec
                  .interfaceBuilder(e.getSimpleName().toString() + JSonarServiceProcessor.PROXY_SUFFIX)
                  .addModifiers(Modifier.PUBLIC);

          e.getAnnotationMirrors().stream()
                  .filter(annotation -> !StringUtils.equals(JSonarService.class.getName(),
                                          annotation.getAnnotationType().toString()))
                  .forEach(annotation -> newInterface.addAnnotation(AnnotationSpec.get(annotation)));

          return newInterface;
      }
  }
  </code>
</pre>
<p>The SimpleElementVisitor8 has methods for visiting different kinds of elements. Since we are processing a TypeElement,
  we are going to override the visitType method. This method will create a new interface builder using the same name as the service
  concatenated with a suffix to identify it as a Proxy Interface. It will also make this interface public and copy all annotations from
  our service class except for the @JSonarService annotation.</p>
<pre class="prettyprint">
  <code class="language-java">
  TypeSpec.Builder interfaceBuilder = typeClass.accept(new ProxyInterfaceVisitor(), processingEnv);

  for (Element element : processingEnv.getElementUtils().getAllMembers(typeClass)) {
      if (Objects.equals(ElementKind.METHOD, element.getKind())
              && Objects.nonNull(element.getAnnotation(Path.class))) {
          ExecutableElement methodElement = (ExecutableElement) element;
          classMethods.add(methodElement);

          // Create the method for ProxyInterface
          MethodSpec.Builder proxyMethodBuilder = methodElement.accept(new MethodVisitor(), processingEnv);
          proxyMethodBuilder.addModifiers(Modifier.ABSTRACT);
          MethodSpec method = proxyMethodBuilder.build();
          interfaceBuilder.addMethod(method);

          checkForDependencies(element, sourcesToWrite);
      }
  }
  </code>
</pre>
<p>After creating a builder for our interface, we need to process all methods annotated with @Path. We are going to use
  another Visitor to create a builder for each method. After we create the method's builder, we make it abstract (because it's an interface)
  and we add it to our interface.</p>
<pre class="prettyprint">
  <code class="language-java">
  public class MethodVisitor extends SimpleElementVisitor8&lt;MethodSpec.Builder, ProcessingEnvironment&gt; {
      @Override
      public MethodSpec.Builder visitExecutable(ExecutableElement e, ProcessingEnvironment processingEnvironment) {
          MethodSpec.Builder method = MethodSpec.methodBuilder(e.getSimpleName().toString())
                  .addModifiers(e.getModifiers())
                  .returns(TypeName.get(e.getReturnType()));

          e.getParameters().forEach(parameter -> {
              ParameterSpec.Builder parameterSpec = ParameterSpec.builder(
                      TypeName.get(parameter.asType()),
                      parameter.getSimpleName().toString(),
                      parameter.getModifiers().toArray(new Modifier[parameter.getModifiers().size()])
              );

              parameter.getAnnotationMirrors().forEach(
                  annotation -> parameterSpec.addAnnotation(AnnotationSpec.get(annotation))
              );
              method.addParameter(parameterSpec.build());
          });

          e.getThrownTypes().forEach(exception -> method.addException(TypeName.get(exception)));
          e.getAnnotationMirrors().forEach(annotation -> method.addAnnotation(AnnotationSpec.get(annotation)));

          return method;
      }
  }
  </code>
</pre>
<p>Our method visitor will create a method builder copying the signature, all parameters and its annotations, all exceptions and all method annotations
  from the service class. Everything need to be copied because the RestEasy proxy framework will make use of these information
  to invoke our remote service.</p>

<h4>Custom Classes</h4>
<p>Some services might receive or return a custom class object. We can not guarantee that our client will have all custom classes in its class path,
  so it is necessary to add theses classes to the new library that contains our service client code.
  The method checkForDependencies will, recursively, look for all custom classes in our service class and will create the dependencies.
  <i>There is a problem with this approach</i>: We do not have access to method's implementation during annotation processing.
  This problem will result in not being able to copy any method that is not a getter or a setter.
  There is still no solution for this problem.</p>

<h4>Rest Client Code Generation</h4>
<p>After generating the proxy interface, we need to generate the code for invoking the services.</p>
<pre class="prettyprint">
  <code class="language-java">
  TypeElement typeClass = (TypeElement) annotatedClass;

  TypeSpec.Builder classBuilder = typeClass.accept(new ClassVisitor(), processingEnv);
  List&lt;ExecutableElement&gt; classMethods = new ArrayList<>();

  // ...

  classMethods.forEach((methodElement) -> {
      MethodSpec.Builder builder = methodElement.accept(new MethodVisitor(), processingEnv);
      MethodSpec method = builder.build();
      List&lt;String&gt; parameterNameStream = methodElement.getParameters()
              .stream()
              .map(parameter -> parameter.getSimpleName().toString())
              .collect(Collectors.toList());

      builder.addStatement("$1T client = ($1T) $2T.newBuilder().register($3T.class).build()",
              ResteasyClient.class, ClientBuilder.class, ResteasyJackson2Provider.class);
      builder.addStatement("$T target = client.target($T.fromPath($S))",
              ResteasyWebTarget.class,
              UriBuilder.class,
              options.get(SERVICE_ADDRESS_OPTION) + options.get(SERVICE_PATH_OPTION));
      builder.addStatement("$1N proxy = target.proxy($1N.class)", newInterfaceType);
      builder.addStatement("return proxy.$N($L)", method, StringUtils.join(parameterNameStream, ","));

      classBuilder.addMethod(builder.build());
  });
  </code>
</pre>
<p>The previous code creates a builder for each method and add the method implementation.
  This methods will make use of the Proxy Interface to invoke the service.</p>

<h3>Maven</h3>
<pre class="prettyprint">
  <code class="language-java">
  public static void main(String[] args) {
      System.out.println("Hello World!!!!");
  }
  </code>
</pre>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</body>
</html>